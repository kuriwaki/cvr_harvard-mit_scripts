# static paths
PATH_CONTESTS = "metadata/contests.csv"
CLEAN_DIR = "data/pass1"

# uneeded columns to drop from the data
DROP_COLS <- c(
  "Cast Vote Record", "Ballot Style", "RowNumber",
  "BoxID", "BoxPosition", "BallotID", "BallotStyleID",
  "PrecinctStyleName", "ScanComputerName", "Status", "Remade",
  "PrecinctStyleName (Redacted to Protect Voter Privacy)",
  "Cvr Number", "Tabulator Num", "Batch Id", "Record Id",
  "Imprinted Id", "Ballot Type", "Counting Group", "Precinct Portion",
  "Dummy Row Number", "Row Number", "Image Path", "Session Type", "Cast.Vote.Record",
  "Ballot.Style", "Voter Flag", "Modified", "Card Info", "Pdf Name", "Unique Voting Identifier",
  "Voting Session Identifier", "CVRNumber", "BallotTypeId",
  "TabulatorId", "BatchId", "RecordId", "Tabulator Name", "Is Current",
  "Box Id", "Box Position", "Ballot Id", "Ballot Style Id", "Scan Computer Name"
)

REDACT_NAMES = c("X", "redacted for voter privacy", "REDACTED", "Redacted", "*")

# various permutations of the precinct column name
RENAME_COLS <- c(
  precinct = "Precinct Portion",
  precinct = "PrecinctPortionID",
  precinct = "Precinct",
  precinct = "PrecinctID",
  precinct = "Precinct Id",
  precinct = "PrecinctId",
  precinct = "Precinct Portion Id",
  precinct = "PrecinctBySplit",
  precinct = "PrecinctPortionId",
  precinct = "Precinct ID",
  precinct = "precinct_number",
  precinct = "PRECINCT CODE",
  precinct = "PRECINCT NAME"
)

#' Check if delimited file has an unconventional header
#'
#' @param path the path to the delimited file
#'
#' @return boolean
is_header <- function(path) {

  # get the top-left cell's contents
  if (str_detect(path, "csv$|CSV$")) {
    d <- read_csv(path,
      n_max = 1, col_select = 1, name_repair = "unique_quiet",
      col_names = FALSE, show_col_types = FALSE
    ) |> pull()
  } else if (str_detect(path, "xls$|xlsx$|XLS$|XLSX$")) {
    d <- read_excel(path, range = "A1", col_names = FALSE, .name_repair = "unique_quiet") |> pull()
  }
  
  # if we detect the top left column to include something like this, it's almost certainly
  # a header file. There may be a more systematic way to check for headers but this 
  # works without fail on every file in the data
  if (str_detect(d, regex("2020|General|November", ignore_case = TRUE))) {
    message(sprintf("\nTOP LEFT CELL OF HEADER FILE IS %s", d))
    return(TRUE)
  }
  
  return(FALSE)
}

#' Process delimited files with unconventional headers. They are
#' generated by one of the voting machine vendors, and include
#' the name of the election in the top left, then a blank line, then
#' three rows of information on each column. Sometimes the order of the rows varies
#' but they always include the contest, the name of the candidate, and their party.
#' In addition, the first m columns are metadata columns related to the CVR. This
#' function processes these files into a more regular delimited format, with a singular
#' row for the header. There is also an edge case in some counties (e.g., San Diego, CA)
#' wherein the header is inexplicably repeated partway through the file. The chunk that
#' generates `bad_rows` removes this extra information.
#'
#' @param path The path to the file
#' @param n The number of rows to read. This is used to generate the raw contests
#' quickly, without reading the entire file.
#'
#' @return A tibble formatted with conventional headers
header_processor <- function(path, n = Inf) {
  df <- read_csv(
    path,
    col_types = cols(.default = "c"),
    skip = 1,
    n_max = n,
    show_col_types = FALSE
  )
  
  bad_rows = which(df[20] == colnames(df)[20] |> str_remove("\\.\\.\\.\\d+")) |> 
    map(~ (.x - 1):(.x + 2)) |> 
    unlist()
  
  colnames(df) = paste(colnames(df), df[1, ], df[2, ], sep = "_") |> 
    str_remove("\\.\\.\\.\\d+") |> 
    str_remove_all("_NA") |> 
    make_clean_names(case = "title") |> 
    iconv(to = "UTF-8", sub = "")
  
  df[-c(bad_rows, 1, 2), ]
  
}
