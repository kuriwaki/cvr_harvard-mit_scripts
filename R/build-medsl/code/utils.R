# static paths
PATH_CONTESTS = "metadata/contests.csv"
CLEAN_DIR = "data/pass1"

# uneeded columns to drop from the data
DROP_COLS <- c(
  "Cast Vote Record", "Ballot Style", "RowNumber",
  "BoxID", "BoxPosition", "BallotID", "BallotStyleID",
  "PrecinctStyleName", "ScanComputerName", "Status", "Remade",
  "PrecinctStyleName (Redacted to Protect Voter Privacy)",
  "Cvr Number", "Tabulator Num", "Batch Id", "Record Id",
  "Imprinted Id", "Ballot Type", "Counting Group", "Precinct Portion",
  "Dummy Row Number", "Row Number", "Image Path", "Session Type", "Cast.Vote.Record",
  "Ballot.Style", "Voter Flag", "Modified", "Card Info", "Pdf Name", "Unique Voting Identifier",
  "Voting Session Identifier", "CVRNumber", "BallotTypeId",
  "TabulatorId", "BatchId", "RecordId", "Tabulator Name", "Is Current",
  "Box Id", "Box Position", "Ballot Id", "Ballot Style Id", "Scan Computer Name"
)

# various permutations of the precinct column name
RENAME_COLS <- c(
  precinct = "Precinct Portion",
  precinct = "PrecinctPortionID",
  precinct = "Precinct",
  precinct = "PrecinctID",
  precinct = "Precinct Id",
  precinct = "PrecinctId",
  precinct = "Precinct Portion Id",
  precinct = "PrecinctBySplit",
  precinct = "PrecinctPortionId",
  precinct = "Precinct Style Name",
  precinct = "Precinct ID",
  precinct = "precinct_number",
  precinct = "PRECINCT CODE",
  precinct = "PRECINCT NAME"
)

#' Check if delimited file has an unconventional header
#'
#' @param path the path to the delimited file
#'
#' @return boolean
is_header <- function(path) {

  # get the top-left cell's contents
  if (str_detect(path, "csv$|CSV$")) {
    d <- read_csv(path,
      n_max = 1, col_select = 1, name_repair = "unique_quiet",
      col_names = FALSE, show_col_types = FALSE
    ) |> pull()
  } else if (str_detect(path, "xls$|xlsx$|XLS$|XLSX$")) {
    d <- read_excel(path, range = "A1", col_names = FALSE, .name_repair = "unique_quiet") |> pull()
  }
  
  # if we detect the top left column to include something like this, it's almost certainly
  # a header file. There may be a more systematic way to check for headers but this 
  # works without fail on every file in the data
  if (str_detect(d, regex("2020|General|November", ignore_case = TRUE))) {
    message(sprintf("\nTOP LEFT CELL OF HEADER FILE IS %s", d))
    return(TRUE)
  }
  
  return(FALSE)
}

#' Process delimited files with unconventional headers. They are
#' generated by one of the voting machine vendors, and include
#' the name of the election in the top left, then a blank line, then
#' three rows of information on each column. Sometimes the order of the rows varies
#' but they always include the contest, the name of the candidate, and their party.
#' In addition, the first m columns are metadata columns related to the CVR. This
#' function processes these files into a more regular delimited format, with a singular
#' row for the header
#'
#' @param path The path to the file
#' @param n The number of rows to read. This is used to generate the raw contests
#' quickly, without reading the entire file.
#'
#' @return A tibble formatted with conventional headers
header_processor <- function(path, n = Inf) {
  # read in file, skipping the first row (this contains the file label only)
  df <- read_csv(path,
    col_types = cols(.default = "c"),
    skip = 1,
    n_max = n,
    name_repair = "unique_quiet",
    show_col_types = FALSE
  )
  
  # force rows 2-4 to be the new column names
  colnames(df) <- paste(colnames(df), df[1, ], df[2, ], sep = "_")
  df <- df[-1:-2, ]
  
  # then, clean up the column names to something more sensible
  # and return the df
  d <- rename_with(df, ~ make_clean_names(str_remove_all(
    str_remove(
      .x,
      "\\.\\.\\.\\d+"
    ),
    "_NA"
  ), case = "title"))
  
  colnames(d) <- iconv(colnames(d), to = "UTF-8", sub = "")
  
  d
}